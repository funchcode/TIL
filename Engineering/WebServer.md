## "목차" <br>
1. [웹서버와 WAS](#웹서버와-WAS-)
2. [Apache 작동원리](#apache-작동원리-)
3. [Nginx](#nginx-)
4. [로드밸런싱](#로드밸런싱-)
5. [프록시](#proxy-)

---
## 웹서버와 WAS <br>

#### 웹 서버 <br>

클라이언트가 서버에 페이지를 요청하면 요청을 받아 정적 컨텐츠(html, css, png 등)을 제공하는 서버이다. <br>
클라이언트에서 요청이 올 때 가장 앞에서 요청에 대한 처리를 한다. <br>

```javascript
if("정적컨텐츠(html, css, png 등)") {
    // 내가 제공해줄게 !
}
else {
    // 정적컨텐츠가 아니구나.. WAS야 니가 해라 !
}
```
<br>
#### WAS <br>

동적 컨텐츠를 제공하기 위해 만들어진 애플리케이션 서버(DB조회, 로직처리가 요구되는 컨텐츠) <br>
<br>
웹 서버에서 요청이 들어오면 컨테이너가 받아서 처리한다.<br>
컨테이너는 web.xml을 참조하여 해당 서블릿에 대한 쓰레드를 생성하고 httpServletResponse, httpServletRequest 객체를 생성하여 전달한다. <br>
컨테이너는 서블릿을 호출한다. <br>
호출된 서블릿의 작업을 담당하는 doGet(), doPost() 메서드는 생성된 동적 페이지를 Response객체에 담아 컨테이너에 전달한다. <br>
컨테이너가 받은 Response객체를 HTTPResponse형태로 바꿔 웹 서버에 전달하고 생성되었던 스레드는 종료하고 httpServletResponse, httpServletRequest를 소멸시킨다. <br>
<br>
WAS는 정적, 동적 처리 둘다 가능하지만 WAS가 하게되면 부하가 많이 발생해서 좋지 않다. <br>
<br>
둘을 따로 두고 쓰는 이유는 성능때문이라고 하는 건 잘못된거라고 한다. <br>
톰캣 5.5 이상부터는 httpd의 native모듈을 사용해서 정적파일을 처리하는 기능을 제공하는데 이것이 순수 아파치 httpd만 사용하는 것과 비교해서 성능적으로 뒤쳐지지 않는다고 한다. <br>
그럼 왜 따로두냐 하나의 서버에 php애플리케이션과 java애플리케이션을 함께 사용하거나, httpd 서버를 간단한 로드밸런싱을 수행하기 위해 사용한다. <br>

---
## Apache 작동원리 <br>

Apache에는 2가지의 MPM(Multi Processing Module:다중처리모듈)이 있다. <br>
<br>
바로 Prefork와 worker방식이다.<br>
<br>
#### Prefork <br>

Prefork방식은 스레드가 한개의 자식 프로세스를 여러개 사용하며 각 프로세스는 한 번에 한 연결을 담당한다. <br>
또한 실행중인 프로세스를 메모리 영역까지 복제하여 실행하기 때문에 프로세스가 메모리를 많이 소비한다. <br>
<br>
하지만 메모리를 공유하지 않고 독립적인 메모리를 할당받기 때문에 안정적이라고 볼 수 있다. <br>
<br>

#### Worker <br>

Worker방식은 한 자식프로세스 당 여러개의 쓰레드를 사용한다. <br>
쓰레드는 최대 64개까지 사용할 수 있으며, 지정된 만큼의 프로세스와 각 스레드를 준비하여 클라이언트 요청을 받아들인다. <br>
스레드 간에는 메모리를 공유하기 때문에 prefork방식보다 메모리 소비가 적다. <br>
동시 접속자 수가 많거나 다중 CPU일 경우 적합하다. <br>

---
## Nginx <br>

Eginx의 가장 유명한 특징으로는 Event Driven 방식을 말할 수 있다. <br>
무슨 말이냐면 요청이 들어오면 어떤 동작을 해야하는지만 알려주고 다른 요청을 처리하는 방식이다. <br>
<br>
CPU와 관계없이 모든 IO들을 전부 Event Listener로 미루기 때문에 흐름이 끊기지 않고 응답이 빠르게 진행되어 1개의 프로세스로 더 빠른 작업을 할 수 있게 되었다. <br>
이 때문에 Nginx가 System Resource를 적게 처리한다는 장점이 있다고 한다. <br>
<br>
비동기 방식으로 효율적으로 작업들을 처리하는 형식이다. <br>

---
## 로드밸런싱 <br>

하나의 인터넷 서비스가 발생하는 트래픽이 많을 때 여러 대의 서버가 분산처리하여 서버의 로드율 증가, 부하량, 속도저하 등을 고려하여 적절히 분산처리하여 해결해주는 서비스를 말한다. <br>
<br>
#### 설정 <br>

Nginx 설정파일에서 upstream에 backend리스트를 적어주고, reverse proxy설정을 upstream으로 연결해주면 된다. <br>
<br>
Apache 설정파일(worker.properties)과 http_vhost_conf파일을 설정하면된다. <br>
<br>
upstream을 선언해주면 이는 라운드로빈 알고리즘 방식으로 backend를 지정해준다. <br>
앱 서버가 장애가 발생했을 경우 발생하지 않은 서버로 자동으로 연결해준다. <br>

---
## Proxy <br>

클라이언트가 자신을 통해서 다른 네트워크 서비스에 간접적으로 접속할 수 있게 해주는 컴퓨터나 애플리케이션을 말한다. <br>
서버와 클라이언트의 중계기로서 대리로 통신을 수행하는 기능을 가르켜 프록시, 그 중계 기능을 하는 것을 프록시 서버라고 부른다. <br>
<br>
프록시 서버는 프록시 서버에 요청된 내용들을 캐시를 이용해 저장해둔다. <br>
클라이언트가 캐시 안에 있는 내용을 요청했을 경우 원격 서버에서 접속하여 데이터를 가져올 필요가 없기 때문에 전송 시간을 아낄 수 있고 불필요한 외부 연결을 안해도 된다. <br>
서버는 트래픽이 줄어들어 네트워크 병목 현상이 생기는 것을 방지할 수도 있다. <br>
<br>

#### 사용목적 <br>

캐시사용(성능 향상), 보안강화, 내부 서버 정보를 숨김, 트래픽 감시, 방화벽 우회 <br>

#### 종류 <br>

"공개 프록시" <br>
누구나 자유롭게 접속하여 사용할 수 있는 프록시 서버를 말하는데 공개 프록시를 사용하면 자신의 IP주소를 남기지 않고 익명으로 활동하기 쉽기 때문에 크래킹, 악성코드 또는 바이러스 유포 등에 악용되기 쉽다. <br>
<br>
"리버스 프록시" <br>
컴퓨터 네트워크에서 클라이언트를 대신해서 한 대 이상의 서버로부터 자원을 추출하는 프록시 서버이다. <br>
관련 서버들을 위해 임의의 클라이언트가 해당 서버에 접속하는 중간 매개체이다. <br>
리버스 프록시 사용목적<br>
(1)보안, 리버스 프록시 서버를 경유하므로 방어 계층의 역할을 한다. <br>
(2)SSL고속화, SSL고속 처리 장비를 갖춘 프록시 서버 사용 <br>
(3)부하 분산, 여러 서버로 부하를 분산 <br>
(4)Static콘텐츠캐시, 그림 파일 등 static content를 캐싱하여 웹서버 부하를 줄인다.<br>
(5)압축, 콘텐츠를 압축 최적화하여 로딩시간 단축<br>
<br>
"포워드 프록시" <br>
일반적으로 사용하는 Proxy 방식이다. 클라이언트와 애플리케이션 서버 사이에 위치하여 클라이언트가 서버에 애플리케이션 서비스를 요청했을 때 Proxy서버로 요청을 보내게 되고 Proxy서버에서 타겟인 서버로 요청을 중계하게 된다. <br>

---
### ⭐️ 참조자료 (감사합니다:)) ⭐️ <br>
[권영재님의 로드밸런서란](https://nesoy.github.io/articles/2018-06/Load-Balancer) <br>