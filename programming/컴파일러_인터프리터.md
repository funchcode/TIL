# 컴파일러와 인터프리터에 대해 정리한다.

## 스크립트 언어와 컴파일 언어

### 차이점

프로그램을 실행할 때 인간이 이해할 수 있는 언어에서 컴퓨터가 이해할 수 있도록 기계어로 번역을 해줘야 하는데 번역하는 방식이 다르다.

프로그램을 번역하는 방식에 따라 컴파일러(Compiler)방식과 인터프리터(Interpreter)방식으로 구분할 수 있다.

## 컴파일러(Compiler) 번역 방식

```
C, C++, Go
```

### 특징

- 프로그램 전체를 한 번에 번역을 진행한다.
- 번역 후에는 실행파일이 생성된다.

### 단점

- 한 번에 번역해야 하기 때문에 컴파일하는 시간이 꽤나 걸린다.
- 프로그램이 동작하는 운영체제에 따라 해석할 수 있도록 기계어를 생성해야 하므로 운영체제에 맞게 전체 번역(컴파일)을 진행해야 한다.

### 장점

- 번역한 후에는 다시 번역할 일이 없기 때문에 이후에는 실행 속도가 빠르다.

## 인터프리터(Interpreter) 번역 방식

```
Python, Ruby, JavaScript
```

### 특징

- 프로그램에서 사용자가 실행하고자 하는 코드를 그때그때 번역한다.

### 단점

- 그때그때 마다 번역해야하는 특징으로 인해 실행 시간이 컴파일러에 비해 느리다.

### 장점

- 프로그램이 동작하는 운영체제에 인터프리터만 준비되어 있으면 바로 실행 가능하다. (운영체제 이식성이 좋다고 표현)
- 프로그램 코드를 수정하면 즉시 반영됨으로 개발 시 유용하다.

## JVM (Java)

Java 언어는 `JVM(Java Virtual Machine)`에 의해 특별한 컴파일 과정을 가진다.

```
JVM은 Java의 바이트 코드(.class)를 컴파일하는 역할을 한다.
Java가 JVM을 별도로 두는 이유는 운영체제에 따라 컴파일 하는 과정을 위임하여 운영체제를 신경쓰지 않고 프로그램을 작성하기 위함이다.
```

### 컴파일 과정

1. 프로그래머가 Java 소스코드를 작성한다. 이 때 파일의 확장자는 `.java`이다.
2. 자바 컴파일러가 `.java` 소스코드를 컴파일을 하는데 이때 컴파일의 목적은 JVM이 해석할 수 있게 하는 것이고 바이트 코드의 파일(`.class`)을 생성한다.
3. 컴파일된 바이트 코드가 JVM의 클래스 로더(Class Loader)에게 전달한다.
4. 클래스 로더는 동적 로딩(Dynamic Loading)을 진행하면서 런타임 영역(Runtime Data)인 JVM의 메모리에 바이트 코드를 올린다.
5. 실행 엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다. 이 때, 인터프리터 또는 JIT 컴파일러 두 가지 번역 방식을 사용한다.

### JIT 컴파일러(Just-In-Time Compiler)

인터프리터의 느린 실행 속도를 보완하기 위해 도입된 방식이다.

바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 인터프리팅 하지 않고, 바이너리 코드를 직접 실행하는 방식이다.

__* 동작하는 시점__

- JIT 컴파일러가 컴파일하는 조건이 있는데, 이 조건의 임계치에 도달했다고 판단했을 때 동작한다.
- "메서드가 호출된 횟수", "메서드의 루프를 빠져나오기까지 돈 횟수" 두 가지를 기반으로 판단한다.

__* 동작 방식__

- 컴파일이 동작되기 전에 Queue에 들어가 컴파일 대기를 한 후에 컴파일 스레드에 의해 컴파일된다. 기계어로 변환된 코드는 캐시된다.
- 인터프리터로 바이트 코드를 해석하다가 임계치에 도달하면 컴파일을 진행하고 같은 코드가 실행될 때 컴파일된 바이너리 코드로 교체하여 더 빠르게 실행되도록 하는데 이를 "스택 상의 교체(on-stack replacement, ORS)"라고 한다.

## 참고 자료

[Java Compile 전체 과정에 대해서 간략하게 잘 정리된 블로그](https://gyoogle.dev/blog/computer-language/Java/%EC%BB%B4%ED%8C%8C%EC%9D%BC%20%EA%B3%BC%EC%A0%95.html)