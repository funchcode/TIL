## "목차"
1. OOP 정의
2. OOP의 5가지 키워드
3. 키워드1: 클래스 + 객체
4. 키워드2: 추상화
5. 키워드3: 캡슐화
6. 키워드4: 상속
7. 키워드5: 다형성
8. OOP 설계원칙
9. 원칙1: SRP
10. 원칙2: OCP
11. 원칙3: LSP
12. 원칙4: ISP
13. 원칙5: DIP
---

### "OOP 정의"
객체지향프로그래밍(Object-Oriented-Programming)이라고 해석한다. <br>
컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다. <br>
---

### "OOP의 5가지 키워드"
1. 클래스(Class) + 인스턴스(객체)(Objects)
2. 추상화(Abstraction)
3. 캡슐화(Encapsulation)
4. 상속(Inheritance)
5. 다형성(Polymorphism)
---

### "키워드1: 클래스(Class) + 인스턴스(Objects)" 

**클래스(class)**는 어떠한 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성(Attribute)와 행위(Behavior)를 변수와 메서드로 정의한 것을 말한다. <br>
클래스는 객체 생성의 청사진(Blueprint)라고도 한다. <br>
<br>
**객체(Objects)**는 클래스에서 정의한 것을 토대로 실제 메모리 상에 할당된 것으로 실제 프로그램에서 사용되는 데이터를 말한다. <br>
객체는 자신 고유의 속성을 가지면서 클래스에서 정의한 행위를 수행할 수 있다. <br>
<br>
**메서드(Method)와 메세지(Message)**는 클래스로부터 생성된 객체를 사용하는 방법으로서 객체에 명령을 내리는 행위라고 볼 수 있다. 메서드는 한 객체의 속성을 조작하는데 사용하고 메세지는 객체간의 통신이 이루어지는 방법을 말한다. <br>
---

### "키워드2: 추상화(Abstraction)"

어떤 영역에서 필요로 하는 속성이나 행동을 추출하는 작업을 말한다. <br>
사물들의 공통된 특징, 즉 추상적 특징을 파악해서 인식의 대상으로 삼는 행위를 말한다. <br>
구체적인 사물들의 공통적인 특징을 파악해서 이를 하나의 개념(집합)으로 다루는 수단을 말한다. <br>
<br>
각 개체의 구체적인 개념에 의존하지 말고 추상적 개념에 의존해야 설계를 유연하게 변경할 수 있다. <br>
<br>
추상화란 공통점을 추출해내는 것을 말하는데, 객체들의 공통적인 속성과 메서드를 추출하는 작업이다. <br>
코드상에서 구현(로직) 부분을 제외한 오직 선언 부분만을 설계한다고 생각하면 된다. <br>
---

### "키워드3: 캡슐화(Encapsulation)"

캡슐화를 통해 높은 응집도와 낮은 결합도를 유지할 수 있도록 설계할 수 있고 요구사항을 변경할 때 유연하게 대처가능하게 한다. <br>
**응집도**: 클래스나 모듈 안의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타낸다. <br>
**결합도**: 어떤 기능을 실행하는 데 다른 클래스나 모듈들에 얼마나 의존적인지를 나타낸다. <br>
<br>
캡슐화는 **정보은닉**을 통해 높은 응집도와 낮은 결합도를 갖도록 한다. <br>
정보은닉이란 필요가 없는 정보는 외부에서 접근하지 못하도록 private키워드를 사용하는 것(자바) <br>
<br>
SW는 결합이 많을수록 문제가 많이 발생한다. <br>
변경될 가능성이 큰 것은 외부에서 접근하지 못하도록 private키워드를 붙여 은닉하고 메서드를 통해 정보를 변경하게 한다. <br>
---

### "키워드4: 상속(Inheritance)"

상속이란 부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고 기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 기능만 다시 수정(정의)하여 사용할 수 있게 하는 것이다. <br>
새로운 종류의 서브클래스를 작성하면, 부모 super Class에 이미 내장된 기능들을 사용할 수 있다. <br>
상속의 진가는 추상화를 구조화 하는데에 있다. <br>
<br>
반복된 코드의 중복을 줄여준다. <br>
상위 객체를 재사용해서 하위 객체를 빨리 개발할 수 있도록 한다. <br>
---

### "키워드5: 다형성(Polymorphism)"

하나의 변수명, 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것을 말한다. <br>
다형성은 캡슐화, 상속과 함께 작동해서 객체지향프로그램의 흐름제어를 단순화한다. <br>
<br>
**흐름제어** <br>
- 컴퓨터는 다음에 일어날 일을 알고 있어야 한다.(프로그램이 복잡하게 되는 주요원인)
- 모든 경로를 추적하지 않고서는 객체가 가질 상태의 가능성을 검사 할 방법이 없다.
- 다형성은 상속 계층의 연관된 객체에 메세지를 보냄으로써 단순화를 한다. 
- 객체에 메세지를 보낼 때에는 그 객체는 메세지에 응답할 메서드를 가지고 있어야 한다. 
- 클래스가 상속계층에 연결되어 있다면, 모든 서브클래스는 부모의 인터페이스를 자동으로 상속받는다.
- 어떤 일이라도 슈퍼클래스 객체가 할 수 있는 것이라면 서브클래스 객체도 할 수 있다.
- 비록 서브클래스 객체가 슈퍼클래스 객체가 하는 것처럼 동일한 메세지에 응답할 책임이 있다 하더라도, 메세지는 동일한 동작을 하도록 강제하지 않는다.

<br>
다형성은 서로 다른 클래스가 같은 메세지를 받았을 때 각자의 방식으로 동작하는 능력이라고도 해석할 수 있다. <br>
다형성과 일반화 관계는 코드를 간결하게 할 뿐 아니라 변화에도 유연하게 대처할 수 있다. <br>
---

### "OOP 설계 원칙"

**S(SRP)**: 단일 책임 원칙 <br>
**O(OCP)**: 개방 폐쇄의 원칙 <br>
**L(LSP)**: 리스코프 치환 원칙 <br>
**I(ISP)**: 인스턴스 분리 원칙 <br>
**D(DIP)**: 의존 역전 원칙 <br>
---

### "원칙1: SRP"

Single Responsibility Principle 단일 책임 원칙이라고 해석한다. <br>
Class는 하나의 책임만 가지며 그 책임을 완전히 캡슐화되어야 함을 말한다. <br>
작성된 클래스는 하나의 기능만 가지며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어야 한다는 원칙이다. <br>
하나의 책임을 가지면 변경 사유가 될 수 있는 것도 한가지 이유이다. <br>
책임을 많이 질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높아진다. <br>
---

### "원칙2: OCP"

Open Closed Principle 개방 폐쇄의 원칙이라고 해석한다. <br>
기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다. <br>
설계의 기본(의존 역전 원칙(DIP)와 밀접)이라고 할 수 있다. <br>
OCP에서 위반하지 않은 설계를 할 때 가장 중요한 것은 무엇이 변하는 것인지, 무엇이 변하지 않는 것인지를 구분해야한다. <br>
- 변해야하는 것은 쉽게 변할 수 있게 하고 변하지 않아야 하는 것은 변하는 것에 영향을 받지 않게 해야 한다.

<br>
확장에는 열려있고 수정에는 닫혀 있어야한다. <br>
이 원칙에서 중요한 것은 추상화와 다형성이다.  <br>
---

### "원칙3: LSP"

The Liskov Substiution Principle 리스코프 치환원칙이라고 해석한다. <br>
리스코프 치환원칙은 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 원칙이다.  <br>
LSP의 궁극적인 목표는 다형성을 만족시키기 위한 원칙인데 부모클래스가 사용되는 곳에 자식 클래스로 치환하더라도 문제가 없어야 한다는 의미이다. <br>
<br>
> "Storage"라는 저장을 담당하는 클래스를 선언하고 해당 클래스를 상속받는 <br>
> "DBStorage"와 "FileStorage" 선언했다고 가정한다. <br>
> 각 각의 클래스가 저장하는 메서드는 DBStorage는 insert()로 FileStorage는 fileSave()로 선언되었다고 가정했을 때 <br>
> Storage클래스로 선언하고 파생 클래스로 생성할 경우 각각의 실제 인스턴스 비교(instanceof)해서 클래스에 맞는 저장 메서드를 실행시켜야할 때 메서드 명이 다를 경우 불필요한 작업이 발생하게 된다. <br>
> 만약 Storage클래스에서 save라는 메서드를 생성하고 파생클래스에서 저장에 관한 작업을 할 경우 save메서드를 오버라이드해서 사용한다면 이런 불필요한 작업은 발생하지 않고 원칙을 따라서 작성하여 갖게 되는 장점이라고 볼 수 있다.

---

### "원칙4: ISP"
Interface Segregation Principle 인터페이스 분리 원칙이라고 해석한다. <br>
인터페이스를 클라이언트에 특화되도록 분리시키는 설계 원칙이다. <br>
> 예를 들어 "복합기"라는 상위 인터페이스가 있다고 가정하고 해당 복합기 인터페이스를 구현하는 많은 클라이언트가 있다고 가정한다. <br>
> 복합기 기능을 제공하는 클래스는 매우 비대해질 가능성이 크다. <br>
> 하지만 복합기의 특성상 모든 기능을 클라이언트가 동시에 사용하는 경우가 없다.(프린터기, 복사기, 팩스기)<br>
> 클라이언트와 무관하게 발생한 변화로 클라이언트 자신이 영향을 받지 않으려면 범용의 인터페이스보다는 클라이언트에 특화된 인터페이스를 사용해야 한다. <br>

---

### "원칙5: DIP"
Dependency Inversion Principle 의존 역전 법칙이라고 해석한다. <br>
의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다. <br>
의존성 역전 원칙이란 자주 변경되는 구체 클래스에 의존하면 안된다는 원리이다. <br>
추상화된 것은 구체적인 것에 의존하면 안되고 구체적인 것이 추상화된 것에 의존해야 된다는 뜻이다. <br>
<br>
1. 상위 모듈은 하위 모듈에 종속되어서는 안된다. 둘 다 추상화에 의존해야한다.
2. 추상화는 세부사항에 의존하지 않는다. 세부사항은 추상화에 의해 달라져야 한다.
<br>