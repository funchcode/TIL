## "목차"
1. [OOP 정의](#oop-정의-)
2. [OOP의 5가지 키워드](#oop의-5가지-키워드-)
3. [절차지향](#절차지향-)
3. [키워드1: 클래스 + 객체](#키워드1:-클래스-+-객체-)
4. [키워드2: 추상화](#키워드2:-추상화[Abstraction]-)
5. [키워드3: 캡슐화](#키워드3:-캡슐화[Encapsulation]-)
6. [키워드4: 상속](#키워드4:-상속[Inheritance]-)
7. [키워드5: 다형성](#키워드5:-다형성[Polymorphism]-)
8. OOP 설계원칙
9. 원칙1: SRP
10. 원칙2: OCP
11. 원칙3: LSP
12. 원칙4: ISP
13. 원칙5: DIP

---

## OOP 정의 <br>

👉🏽 **객체지향프로그래밍(Object-Oriented-Programming)이라고 해석한다.** <br>

> 컴퓨터 프로그래밍 패러다임 중 하나로, 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 정의하고 많은 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법이다.

🤔 객체지향의 장점을 느끼기 위해서는 **절차지향** 프로그래밍 패러다임을 알면 좋다. <br>


---

## OOP의 5가지 키워드 <br>

👉🏽 **대표적인 OOP의 특징을 나타내는 키워드 5가지이다.** <br>

> 객체지향 프로그래밍 패러다임을 사용하는 이유(Why)를 생각해보면서 키워드를 생각해보자.

1. **클래스(Class) + 인스턴스(객체)(Objects)**
2. **추상화(Abstraction)**
3. **캡슐화(Encapsulation)**
4. **상속(Inheritance)**
5. **다형성(Polymorphism)**

---
## 절차지향 <br>


👉🏽 **절차지향(Procedural-Programming)**을 간략히 살펴본다. <br>

▶︎ **절차지향 방식 프로그래밍** <br>
절차지향으로 프로그래밍을 한다는 말은 데이터를 조작하는 코드를 별도로 분리해서 함수나 프로시저와 같은 형태로 만들고 각 프로시저들이 데이터를 조작하는 방식으로 코드를 작성하는 것을 말한다. <br>
절차지향으로 프로그래밍을 하게 되면 다수의 함수(프로시저)들이 데이터를 공유해서 사용하는 모양이 만들어진다. <br>

```java
class 흐름클래스 {
    private static 평균 평균구하기(학생들 점수) {
        // 코드
    }

    private static 출력 화면에노출(학생들 점수, 학생들 평균) {
        // 코드
    }

    public static void main(String[] args) {
        int[학생 수] 성적 = {...};

        int 평균 = 평균구하기(성적);

        화면에노출(성적, 평균);
    }
}
```
각 프로시저(평균구하기, 화면에노출)는 데이터(성적)를 공유하면서 작업이 흘러가는 것을 볼 수 있다. <br>
절차지향으로 프로그래밍을 하게된다면 자연스럽게 **데이터를 중심**으로 구현하게 되는 특징이 있다. <br>
<br>

🚨 **데이터 중심으로 구현하는 절차지향의 문제점** <br>

데이터 타입이나, 의미를 변경이 필요할 경우 데이터를 공유하거나 이용하기 때문에 연쇄적으로 수정이 발생하게 된다. <br>
또는 같은 데이터를 프로시저들이 서로 다르게 해석하여 사용하는 경우가 발생할 수도 있다. <br>
> 예를 들어서 null, boolean 데이터의 의미를 다른 해석으로 사용하여 꼬일 수 있다.


---
## 키워드1: 클래스 + 객체 <br>

👉🏽 **객체지향은 데이터 및 데이터와 관련된 프로시저를 객체라는 단위로 묶는다.** <br>
> 객체가 제공하는 기능을 오퍼레이션(Operation) <br> 오퍼레이션 사용법을 나타내는 식별이름, 파라미터, 결과 값을 말하는 시그니처(Signature) <br> 객체가 제공하는 모든 오퍼레이션 집합을 객체의 인터페이스(interface) <br> 다른 인터페이스와 구분되는 명칭이 타입(Type)


<br>

▶︎ **클래스(class)** <br>
어떠한 문제를 해결하기 위한 데이터를 만들기 위해 문제를 추상화를 거쳐 속성과 행위, 즉 변수와 메서드로 정의한 것을 말한다. <br>
<br>
▶︎ **객체(Objects)** <br>
클래스에서 정의한 것을 토대로 실제 메모리 상에 할당된 것으로 실제 프로그램에서 사용되는 데이터를 말한다. <br>
객체는 자신 고유의 속성을 가지면서 클래스에서 정의한 행위를 수행할 수 있다. <br>
<br>
▶︎ **메세지(Message)** <br>
객체지향은 여러 객체들이 모여서 완성된 어플리케이션을 구성하게 되는 특징이 있는데, 특정 객체에 오페레이션을 실행해달라고 요청하는 것을 **메세지**를 보낸다라고 표현한다. <br>
메세지를 통해 객체들과 연결하게 된다. <br>

---

## 키워드2: 추상화[Abstraction] <br>

👉🏽 **데이터나 프로세스 등을 의미가 비슷한 개념으로 또는 표현으로 정의하는 과정을 말한다.** <br>
<br>

▶︎ **비슷한 개념으로 추상화하게 되면 코드가 구현 교체가 유연해진다.** <br>
> 책: [개발자가 반드시 정복해야 할 객체지향과 디자인패턴](http://www.yes24.com/Product/Goods/9179120?Acode=101) 인용

비슷한 행위(읽기, 쓰기)를 하는 객체들이 있을 경우 이 객체들을 이용하기 위해서는 IF-ELSE 구문을 피할 수 없을 것이다. <br>
또한 비슷한 행위를 하는 요구사항이 들어온다면 IF-ELSE 구문을 자연스레 사용하게 되어 코드를 복잡하고 가독성이 떨어지는 코드가 될 것이다. <br>
<br>

```java
class 황인 {...}

class 백인 {...}

class 흑인 {...}

class HelloWorld {
    흐름제어() {
        String talk = null;
        if(백인) {
            백인 p1 = new 백인();
            talk = p1.hello();
        } else if(흑인) {
            흑인 p2 = new 흑인();
            talk = p2.hello();
        } else {
            황인 p3 = new 황인();
            talk = p3.hello();
        }
    }
}
```
아주 촌스러운 위의 코드를 보면 공통점을 너무나 쉽게 찾을 수 있다. <br>
모든 인종이 hello()라는 오퍼레이션을 사용하는 것을 볼 수 있다. <br>
<br>

```java
public interface GoodPeople {
    public String hello();
}
```
촌스러운 코드에서 추상화를 통해 GoodPeople이라는 추상타입을 만들었다. <br>
이제 추상타입을 이용하도록 코드를 수정한다.
<br>

```java
class 백인 implements GoodPeople {
    public String hello() {
        ...
    }
}
class 흑인 implements GoodPeople {
    public String hello() {
        ...
    }
}

...
```
백인, 흑인, 황인 클래스 모두 GoodPeople 타입을 상속받았으므로 이 클래스들은 다형성을 통해 GoodPeople 타입으로도 동작한다. <br>
<br>

```java
class HelloWorld {
    흐름제어() {
        String talk = null;
        GoodPeople p = null;
        if(백인) {
            p = new 백인();
        } else if(흑인) {
            p = new 흑인();
        } else {
            p = new 황인();
        }
        talk = p.hello();
    }
}
```
IF-ELSE 블록이 남아있지만 좀 단순해진 코드를 볼 수 있다. <br>
위의 GoodPeople 인터페이스에 정의된 기능을 실제로 구현하는 클래스들을 콘크리트 클래스(concrete class)라고 부른다. <br>
IF-ELSE 블록을 처리해야 GoodPeople의 콘크리트 클래스가 변경해도 HelloWorld 코드를 손대지 않을 수 있다. <br>
<br>
▶︎ **IF-ELSE 블록을 처리하는 방법 두가지** <br> 
**1 ) GoodPeople 타입의 객체를 생성하는 기능을 별도 객체로 분리한 뒤, 그 객체를 이용하여 객체를 생성.** <br>
**2 ) 생성자, 메서드를 이용하여 GoodPeople 타입의 객체를 전달받는다.** <br>
<br>
2의 방법은 DI, 서비스 로케이터를 이용하는 것인데 아래 설계 원칙에서 해석해본다. <br>
<br>

▶︎ **추상화하는 방법** <br>
변경되지 않는 코드보다는 변화되는 부분을 추상화한다. <br>
추상 타입으로 교체하면 향후 변경에 유연하게 대처할 수 있기 때문이다. <br>
TDD 테스트 주도 개발을 하다보면 Mock객체를 사용해야 하는 경우가 많이 발생하는데 이는 하나의 책임이 되고 이 책임은 곧 추상화가 될 자격이기 때문에 자연스레 추상화를 연습할 수 있다. <br>

---

## 키워드3: 캡슐화[Encapsulation] <br>

👉🏽 **한 곳의 구현이 다른 곳에 변경을 가하지 않도록 해준다.** <br>
<br>
캡슐화를 통해서 한 곳의 변화가 다른 곳에 미치는 영향을 최소화한다. <br>
<br>
▶︎ **캡슐화를 위한 두 개의 규칙** <br>  
1 ) Tell, Don't Ask <br>
2 ) 데미테르의 법칙 <br>
<br>
"Tell, Don't Ask"는 데이터를 물어보지 않고, 기능을 실행해 달라고 말하라는 규칙이다. <br>
데이터를 물어본다는 것은 객체의 데이터를 받아서 받은 객체에서 데이터를 가공하는 방식의 코드인데, 그럼 데이터를 중심으로 코드를 작성하게 되는 절차지향적인 코드로 작성하게 된다. <br>
<br>

```java
class ROKMC {
    private Date 전역;
    private boolean 전문하사;

    public Date get전역() {
        return 전역;
    }
    public boolean is전문하사() {
        return 전문하사;
    }
}

class Flow {
    흐름제어() {
        ROKMC man = new ROKMC();

        if(man.get전역() != null && man.get전역().getDate() < System.currentTimeMillis()) {
            // 코드
        }
    }
}
```
위의 코드를 보면 ROKMC객체에서 직접 전역 날을 가져와 계산하는 로직을 가지고 있다. <br>
Flow 클래스 뿐 아니라 다른 클래스에도 같은 형태의 코드가 사용된다고 가정해보자. <br>
여기서 추가(+)로 전문하사인지 여부의 요구사항이 추가된다고 생각해보면 이곳저곳에서 사용되는 이러한 형태의 코드를 모두 찾아서 모두 수정해줘야 한다. <br>
> 요구 사항의 변화로 인해 데이터의 구조나 쓰임새가 변경되면 이로 인해 데이터를 사용하는 코드들도 연쇄적으로 수정해야 한다.

<br>
위의 전역날을 계산하는 로직을 ROKMC 클래스에 기능을 정의해보도록 하자.(캡슐화) <br>

```java
class ROKMC {
    ....데이터....

    public boolean is전역() {
        if(전역 != null && 전역.getDate() < System.currentTimeMillis()) {
            return // 코드
        }
        return // 코드
    }
}

class Flow {
    흐름제어() {
        ROKMC man = new ROKMC();

        if(man.is전역()) {

        }
    }
}
```
위의 코드가 되었다고 살펴보면 ROKMC에 기능이 들어가있기 때문에 추가 요구사항이 발생하면 ROKMC의 is전역()의 오퍼레이션만을 수정해주면 된다는 것을 볼 수 있다. <br>
Flow 클래스에는 수정을 할 필요가 없다. <br>
ROKMC 클래스의 요소들은 더욱 응집했고 Flow클래스와 ROKMC객체간의 결합도 즉 의존도가 낮아졌다는 것을 느낄 수 있다. <br>
<br>
또한 캡슐화를 하면 private 등의 접근제한자를 이용하여 정보를 감출 수가 있다. <br>
객체를 이용하다보면 해당 데이터나 기능의 의미를 확실하게 구분하게 하여 의도하지 않은 사용을 제한할 수 있다는 이점이 있다. <br>
<br>
▶︎ **데미테르의 규칙** <br>
**메서드에서 생성**한 객체의 메서드만 호출한다. <br>
**파라미터로 받은** 객체의 메서드만 호출한다. <br>
**필드로 참조**하는 객체의 메서드만 호출한다. <br>
<br>
위의 의미를 곱씹어보면 객체의 필드(데이터)에 직접 접근을 제한하고 메세지를 통해 대화한다. <br>

```java
man.get전역().getDate()
```
위의 코드는 데미테르 법칙을 위반한 것이다. 참조하는 객체의 메서드만 호출(1 Deep)을 지향해야한다. <br>

---

### 키워드4: 상속[Inheritance] <br>

👉🏽 상속이란 한 타입을 그대로 사용(이용)하면서 새로운 구현을 추가할 수 있도록 해주는 방법이다. <br>
<br>
부모클래스의 속성과 기능을 그대로 이어받아 일부분을 변경(Overriding) 재정의하여 사용할 수도 있다. <br>
반복된 코드의 중복을 줄여준다. <br>
상위 객체를 재사용해서 하위 객체를 빨리 개발할 수 있도록 한다. <br>

---

## 키워드5: 다형성[Polymorphism] <br>

👉🏽 다형성이란 한 객체가 여러 타입을 가질 수 있다는 것을 말한다. <br>
<br>
다형성은 서로 다른 클래스가 같은 메세지를 받았을 때 각자의 방식으로 동작하는 능력이라고도 해석할 수 있다. <br>
다형성과 일반화 관계는 코드를 간결하게 할 뿐 아니라 변화에도 유연하게 대처할 수 있다. <br>

---

### "OOP 설계 원칙" <br>

**S(SRP)**: 단일 책임 원칙 <br>
**O(OCP)**: 개방 폐쇄의 원칙 <br>
**L(LSP)**: 리스코프 치환 원칙 <br>
**I(ISP)**: 인스턴스 분리 원칙 <br>
**D(DIP)**: 의존 역전 원칙 <br>

---

### "원칙1: SRP" <br>

Single Responsibility Principle 단일 책임 원칙이라고 해석한다. <br>
Class는 하나의 책임만 가지며 그 책임을 완전히 캡슐화되어야 함을 말한다. <br>
작성된 클래스는 하나의 기능만 가지며, 클래스가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어야 한다는 원칙이다. <br>
하나의 책임을 가지면 변경 사유가 될 수 있는 것도 한가지 이유이다. <br>
책임을 많이 질수록 클래스 내부에서 서로 다른 역할을 수행하는 코드끼리 강하게 결합될 가능성이 높아진다. <br>

---

### "원칙2: OCP" <br>

Open Closed Principle 개방 폐쇄의 원칙이라고 해석한다. <br>
기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계가 되어야 한다. <br>
설계의 기본(의존 역전 원칙(DIP)와 밀접)이라고 할 수 있다. <br>
OCP에서 위반하지 않은 설계를 할 때 가장 중요한 것은 무엇이 변하는 것인지, 무엇이 변하지 않는 것인지를 구분해야한다. <br>
- 변해야하는 것은 쉽게 변할 수 있게 하고 변하지 않아야 하는 것은 변하는 것에 영향을 받지 않게 해야 한다.

<br>
확장에는 열려있고 수정에는 닫혀 있어야한다. <br>
이 원칙에서 중요한 것은 추상화와 다형성이다.  <br>

---

### "원칙3: LSP" <br>

The Liskov Substiution Principle 리스코프 치환원칙이라고 해석한다. <br>
리스코프 치환원칙은 서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다는 원칙이다.  <br>
LSP의 궁극적인 목표는 다형성을 만족시키기 위한 원칙인데 부모클래스가 사용되는 곳에 자식 클래스로 치환하더라도 문제가 없어야 한다는 의미이다. <br>
<br>
> "Storage"라는 저장을 담당하는 클래스를 선언하고 해당 클래스를 상속받는 <br>
> "DBStorage"와 "FileStorage" 선언했다고 가정한다. <br>
> 각 각의 클래스가 저장하는 메서드는 DBStorage는 insert()로 FileStorage는 fileSave()로 선언되었다고 가정했을 때 <br>
> Storage클래스로 선언하고 파생 클래스로 생성할 경우 각각의 실제 인스턴스 비교(instanceof)해서 클래스에 맞는 저장 메서드를 실행시켜야할 때 메서드 명이 다를 경우 불필요한 작업이 발생하게 된다. <br>
> 만약 Storage클래스에서 save라는 메서드를 생성하고 파생클래스에서 저장에 관한 작업을 할 경우 save메서드를 오버라이드해서 사용한다면 이런 불필요한 작업은 발생하지 않고 원칙을 따라서 작성하여 갖게 되는 장점이라고 볼 수 있다.

---

### "원칙4: ISP" <br>
Interface Segregation Principle 인터페이스 분리 원칙이라고 해석한다. <br>
인터페이스를 클라이언트에 특화되도록 분리시키는 설계 원칙이다. <br>
> 예를 들어 "복합기"라는 상위 인터페이스가 있다고 가정하고 해당 복합기 인터페이스를 구현하는 많은 클라이언트가 있다고 가정한다. <br>
> 복합기 기능을 제공하는 클래스는 매우 비대해질 가능성이 크다. <br>
> 하지만 복합기의 특성상 모든 기능을 클라이언트가 동시에 사용하는 경우가 없다.(프린터기, 복사기, 팩스기)<br>
> 클라이언트와 무관하게 발생한 변화로 클라이언트 자신이 영향을 받지 않으려면 범용의 인터페이스보다는 클라이언트에 특화된 인터페이스를 사용해야 한다. <br>

---

### "원칙5: DIP" <br>
Dependency Inversion Principle 의존 역전 법칙이라고 해석한다. <br>
의존 관계를 맺을 때 변화하기 쉬운 것 또는 자주 변화하는 것보다는 변화하기 어려운 것, 거의 변화가 없는 것에 의존하라는 것이다. <br>
의존성 역전 원칙이란 자주 변경되는 구체 클래스에 의존하면 안된다는 원리이다. <br>
추상화된 것은 구체적인 것에 의존하면 안되고 구체적인 것이 추상화된 것에 의존해야 된다는 뜻이다. <br>
<br>
1. 상위 모듈은 하위 모듈에 종속되어서는 안된다. 둘 다 추상화에 의존해야한다.
2. 추상화는 세부사항에 의존하지 않는다. 세부사항은 추상화에 의해 달라져야 한다.
<br>