## 알고리즘, 자료구조에 관련 학습 저장소 <br>

---
## 저장소 인덱스 <br>

#### [[BigO.md]빅오](./BigO.md) <br>

빅오 표기법 <br>
빅오 표현방법 <br>
<br>
#### [[Sort.md]정렬 알고리즘](./Sort.md) <br>

선택정렬(Selection sort) <br>  

<br><br><br><br><br><br><br><br><br><br><br>

---
## 이전 히스토리 (정리 필요) <br>

> <span><h3><u>Heap</u></h3></span>
- 우선순위 큐를 위하여 만들어진 자료구조.
- 완전 이진 트리.
- 배열을 이용해서 구현한다.  

**[heap의 종류는 뭐가 있을까 ?]**<br/>
최대 힙(Max Heap) : 부모 노드의 키 값이 자식 노드의 키 값보다 **크거나 같은** 완전 이진 트리 <br/>
최소 힙(Min Heap) : 부모 노드의 키 값이 자식 노드의 키 값보다 **작거나 같은** 완전 이진 트리 <br/>

**[Heap의 삽입 삭제]**<br/>
삽입 :<br/>
- 새로운 요소가 들어오면, 힙의 마지막 노드에 이어서 삽입한다.
- 새로운 노드를 부모 노드들과 비교해서 힙의 성질을 만족시킨다.

삭제 :<br/>
- 루트 노드가 삭제된다.
- 마지막 요소가 루트 노드를 가져온다.
- 루트 노드가 된 마지막 요소를 자식요소와 비교해 힙의 성질을 만족시킨다.

---
> <span><h3><u>트리</u></h3></span>

- 노드(node) : 트리의 요소 하나하나를 의미.
- 루트노드(root) : 최상단의 노드를 의미.
- 단말노드(terminal) : 자식이 없는 노드.
- 서브트리(subTree) : 트리안에 존재하는 트리.
- 브랜치(branch) : 노드와 노드를 연결하는 선.

**[이진트리]**<br/>
이진트리는 각각의 노드가 최대 **두 개의 자식** 노드를 가지는 트리 자료 구조이다.<br/>

**[이진트리를 왜 사용할까 ?]**<br/>
데이터를 저장할 수 있고 시간복잡도 상으로 우수하기 때문에 사용한다.<br/>
부수적인 자료구조나 알고리즘을 만드는데도 사용한다.<br/>

**[이진트리에 들어있는 값을 어떻게 확인해야 할까 ?]**<br/>
세 가지 방법 ["전위순회", "중위순회", "후위순회"]가 있다.<br/>
- 전위순회(Preorder) : 루트 > 왼쪽서브트리 > 오른쪽서브트리
- 중위순회(Inorder) : 왼쪽서브트리 > 루트 > 오른쪽서브트리
- 후위순회(Postorder) : 왼쪽서브트리 > 오른쪽서브트리 > 루트
방법을 코드로 구현하면 된다.<br/>

**[이진트리 어떻게 구현하면 될까 ?]**<br/>
이진 트리의 구현은 **배열**과 **연결리스트** 둘로 나뉜다.<br/>
둘의 장단점의 차이는 크기 때문에 둘다 알 필요가 있다.<br/>

1. **배열**
배열의 구현은 연결리스트의 구현 보다 복잡하다.<br/>
힙트리의 경우 배열로 구현하게 되는 경우가 많단다.<br/>
최상단 루트 Index = 0<br/>
어떤 임의의 노드 arr[n]에서 다른 부모나 형제노드들을 단 한 번에 갈 수 있다.<br/>
배열의 인덱스를 이용하면 되는데 부모노드(/2), 자식노드(\*2), 홀수(+1), 짝수(-1)<br/>
- 장점 : 시간복잡도를 더 줄일 수 있다.<br/>
- 비교(연결리스트) : 양방향 연결리스트는 자식, 부모노드를 접근할 수 있지만 메모리를 많이 잡아먹는다.<br/>
- 단점1 : 트리의 규모가 커졌을 경우, 사용에 비직관적이다.<br/>
- 단점2 : null처리를 하기에 애매하다.<br/>
- 단점3 : 벡터나 동적배열형식이 아닌 고정배열이라면 배열 크기의 문제<br/>
- 단점4 : 크기를 늘려 만들었다해도 트리의 크기를 판단하기 어렵다(null 등).<br/>

2. **연결리스트**
배열로 구현하는 것보다 훨씬 쉽단다.<br/>
- 장점 : 접근에 굉장히 직관적이다. 배열과는 다르게 신경써야 할 부분이 적다.<br/>
- 단점 : 배열은 임의접근이 가능하지만, 연결리스트는 불가능하다.<br>


**[이진트리와 관련된 이름들은 무슨 차이가 있을까 ?]**<br/>
- 사향이진트리 : 한 쪽(오른쪽 OR 왼쪽)으로 치우친 트리를 의미한다.<br/>
	- 이 트리의 특징을 보면 연결리스트와 같은 것을 알 수 있다.<br/>
- 완전이진트리 : 위에서 아래, 왼쪽에서 오른쪽으로 순서대로 채워지는 트리를 말한다.<br/>
	- 순서대로 채워지니 레벨 차이는 1밖에 안 난다.<br/>
	- 시간복잡도가 굉장히 우수하고 힙 트리와 같다.<br/>
- 포화이진트리 : 정삼각형인 트리라고 보면 된다.<br/>
	- 깊이 -1인 모든 노드들은 양쪽 자식을 모두 가지고 그 자식들은 자식노드가 하나도 없다.<br/>

**[이진트리는 알겠는데 이진탐색트리는 뭘까 ?]**<br/>
임의의 수에서 특정한 수를 찾는데는 O(n)의 시간이 걸린다.<br/>
왜 ? 일일이 확인해야 되니깐.<br/>
수가 정렬되어 있다고 가정하면 이진 탐색을 하면 상당히 빨라진다.<br/>
반으로 쪼개고 쪼개고... 쪼.. 개. 고. 찾는다.<br/>
이진 탐색트리는 트리 자체가 이진 탐색을 항상 하고 있는 트리이다.<br/>
정렬되어 있어야 하기 때문에 임의의 값을 추가하면 그 자리를 찾아 넣어줘야한다.<br/>
따라서 이진 탐색트리는 값이 추가되거나 삭제되거나 할 때 큰 변동이 있게 되고 노드 값을 변경하게 될 경우 트리모양자체가 바뀐다.<br/>

**[균형]**

**[비균형]**

**[포화이진트리/완전이진트리]**

**[트라이]**

**[레드블랙 트리]**

---
> <span><h3><u>그래프</u></h3></span>

**[너비우선탐색]**

**[깊이우선탐색]**
