## "목차" <br>
1. [데이터베이스](#데이터베이스-)
2. [데이터베이스 특징](#데이터베이스-특징-)
3. [인덱스](#인덱스-)
4. [인덱스 자료구조](#인덱스-자료구조-)
5. [정규화](#정규화-)
6. [정규화의 장단점](#정규화의-장단점-)
7. [반정규화](#반정규화-)
8. [트랜잭션](#트랜잭션-)

---
## 데이터베이스 <br>

**데이터베이스 사용이유** <br>
데이터베이스가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였다. <br>
데이터를 각각의 파일로 보관하면 발생하는 문제점들 때문에 데이터베이스가 나왔다. <br>
<br>
**파일 시스템의 문제점** <br>
- 데이터 종속성 : 프로그램의 구조가 데이터의 구조에 영향을 받는 것을 말한다.
    + 데이터의 종속성 때문에 데이터의 구조가 변경되면 프로그램까지 바뀌기 비용이 들기 때문에 프로그램 개발과 유지보수가 어려워진다.
- 데이터 중복성 : 프로그램마다 같은 정보를 중복해서 저장했는데 데이터 종속성으로 인해 공유가 안되었기 때문이다.
    + 이는 저장공간의 낭비이기도 하지만 관리 측면에서 같은 정보를 여러 곳에 저장하면 수정 시에 모든 데이터를 찾아 수정해야하는 문제가 발생한다.
- 데이터 불일치 : 여러 곳에 데이터가 저장되기 때문에 모두 수정하지 않는 한 어떤 것이 올바른 정보인지 알 수 없다.
- 데이터 무결성 : 데이터의 내용이 본래의 의도와 다른 형식을 갖게 될 때 데이터의 무결성을 침해했다고 말한다.

---
## 데이터베이스 특징 <br>

데이터의 독립성 <br>
- 물리적 독립성 : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 응용 프로그램을 수정할 필요가 없다.
- 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양한 응용 프로그램의 논리적 요구를 만족시켜줄 수 있다.

데이터의 무결성 <br>
- 여러 경로를 통해 잘못된 데이터가 들어오는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 된다.

데이터의 보안성 <br>
- 인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원을 사용할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있다.

데이터의 일관성 <br>
- 연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있다.

데이터의 중복 최소화 <br>
- 데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있다.

---
## 인덱스 <br>

DBMS는 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다. <br>
그렇기 때문에 칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다. <br>
<br>
DBMS의 인덱스는 항상 정렬된 상태를 유지하는데 여기서 발생하는 장점은 원하는 값을 탐색할 때 무진장 빠르지만 새로운 값을 추가하거나 기존의 데이터를 삭제할 경우 쿼리문의 속도가 느리다. <br>
<br>
인덱스를 사용하는 건, 결론적으로 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능이다. <br>
<br>
**"인덱스의 성능과 고려해야 할 사항"** <br>
- Index를 생성하게 되면 Update, Delete, Insert 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생한다.
- Insert 시에는 Index에 대한 데이터도 추가해야하므로 그만큼 성능에 손실이 따른다.
- Delete 시에는 Index에 존재하는 값을 삭제하는 것이 아니라 사용 안함 표시로 남겨놓는다.
    + 실제 데이터는 10만 건인데 100만 건이 있는 결과를 초래할 수도 있다.
- Update 시에는 Insert와 Delete의 문제점을 모두 갖는다.

---
## 인덱스 자료구조 <br>

**"B+-Tree 인덱스 알고리즘"** <br>
🏷 [B+-Tree 정리해야 함](./BTree.md) <br>
<br>
**"Hash 인덱스 알고리즘"** <br>
- 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원한다.
- 하지만 값을 변경해서 저장하므로 값의 일부로 검색하고자 할 때는 해시 인덱스를 사용할 수 없다. 
- 주로 메모리 기반의 데이터베이스에서 많이 사용한다.

Hash인덱스를 사용하는 경우 SELECT 시에 등호(==)가 아닌 부등호(<>)연산의 경우에 문제가 생기기 때문에 B- Tree를 사용한다. <br>

---
## 정규화 <br>

한 릴레이션에 여러 엔티티의 애트리뷰트들을 혼합하게 되면 정보가 중복 저장되며 저장공간을 낭비하게 된다. <br>
또한 중복된 정보로 인해 갱신 이상이 발생하게 된다. <br>
<br>
**"갱신이상"** <br>
- 삽입이상 : 원하지 않는 자료가 삽입된다던지 삽입하는데 자료가 부족하여 삽입되지 않는 현상을 말한다.
- 삭제이상 : 하나의 자료만 삭제하고 싶지만, 그 자료가 포함된 튜블 전체가 삭제됨으로 원치 않는 삭제가 발생한다.
- 수정(갱신)이상 : 정확하지 않거나 일부의 튜플만 갱신되어 정보가 모호해지거나 일관성이 없어지는 현상을 말한다.

<br>
정규화란 데이터베이스에서 중복을 최소화하기 위해 데이터를 구조화하는 작업을 말한다. <br>
정규형이란 특정 조건을 만족하는 릴레이션의 스키마 형태를 말한다. <br>
<br>

**"함수적 종속성"** <br>
함수적 종속성이란 애트리뷰트 데이터들의 의미와 애트리뷰트간의 상호 관계로부터 유도되는 제약조건의 일종이다. <br>
X와 Y를 임의의 애트리뷰트 집합이라고 할 때, X의 값이 Y의 값을 유일하게 결정한다면 X는 Y를 함수적으로 결정한다고 한다. <br>
<br>

**"제1정규형"** <br>
- 애트리뷰트의 도메인이 오직 원자값만을 포함한다.
- 튜플의 모든 애트리뷰트가 도메인에 속하는 하나의 값(원자값)을 가져야 한다.

**"제2정규형"** <br>
- 2정규형은 테이블의 모든 칼럼이 완전 함수적 종속을 만족하는 것을 말한다.
- 기본키 중에 특정 칼럼에만 종속된 칼럼(부분적 종속)이 없어야하는 것을 말한다.

**"제3정규형"** <br>
- 3차 정규형은 기본키를 제외한 속성들 간의 이행적 함수 종속이 없는 것을 말한다.
- 풀어서 해석하면 기본키 이외의 다른 칼럼이 그외 다른 칼럼을 결정할 수 없는 것을 말한다.

**"BCNF"** <br>
- BCNF란 3차정규형을 만족하면서 모든 결정자가 후보키 집합에 속한 정규형을 말한다.
- 일반 칼럼이 후보키를 결정하는 경우가 BCNF에 만족하지 않는 것이다.

---
## 정규화의 장단점 <br>

**장점** <br>
데이터베이스 변경 시 이상 현상 제거 <br>
- 삽입, 갱신, 수정 이상현상을 제거함을 말한다.

데이터베이스 구조 확장 시 재 디자인 최소화 <br>
- 새로운 데이터 형의 추가로 인한 확장 시에 그 구조를 변경하지 않아도 되거나 일부만 변경해도 된다.
- 데이터베이스와 연동된 응용 프로그램에 최소한의 영향만을 미치게 된다.

**단점** <br>
릴레이션의 분해로 인해 릴레이션 간의 JOIN연산이 많아진다. <br>
이로 인해서 응답의 시간이 느려질 수도 있다. <br>
정규화를 수행한다는 것은 입력/수정/삭제 이상을 제거 하는 것인데 데이터의 중복 속성을 제거하고 결정자에 의해 동일한 의미의 일반 속성이 하나의 테이블로 집약되므로 한 테이블의 데이터 용량이 최소화되는 효과도 있다. <br>
따라서 정규화된 테이블은 속도가 빨라질 수도 있고 느려질 수도 있다. <br>

---
## 반정규화 <br>

조회를 하는 SQL문에서 조인이 많이 발생하여 이로 인한 성능저하가 나타나는 경우에 반정규화를 적용하는 전략이 필요하다. <br>
<br>
디스크 I/O량이 많아서 조회 시 성능이 저하되거나 테이블끼리의 경로가 너무 멀어 조인으로 인한 성능 저하가 예상되거나 칼럼을 계산하여 조회할 때 성능 저하될 것이 예상되는 경우 반정규화를 수행하게 된다. <br>
<br>
**반정규화 대상** <br>
- 자주 사용되는 테이블에 엑세스하는 프로세스의 수가 가장 많고, 항상 일정 범위만을 조회하는 경우
- 테이블에 대량의 데이터가 있고 대량의 범위를 자주 처리하는 경우, 성능 상 이슈가 있을 경우
- 테이블에 지나치게 조인을 많이 사용하게 되는 경우나 데이터를 조회하는 것이 기술적으로 어려울 경우

---
## 트랜잭션 <br>

트랜잭션이란 작업의 완전성을 보장해주는 것이다. <br>
논리작업 셋이 모두 완벽하게 처리하거나 또는 처리하지 못할 경우 원 상태로 복구해서 작업의 일부만 적용되는 현상을 방지하는 것을 말한다. <br>

<br>

**트랜잭션과 Lock기능** <br>
- Lock : 동시성을 제어하기 위함이다. 여러 커넥션에서 동시에 동일한 자원을 요청할 경우 순서대로 하나의 커넥션만 변경할 수 있게 해주는 역할이다.
- 트랜잭션 : 데이터의 정합성을 보장하기 위한 기능이다. 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않음을 보장해야 한다.

<br>
**트랜잭션의 특성** <br>
- 원자성 : 만약 트랜잭션 중간에 어떠한 문제가 발생한다면 트랜잭션에 해당하는 어떠한 작업도 수행되어서는 안되며 문제되지 않았을 경우에만 모든 작업이 수행되어야 한다.
- 일관성 : 트랜잭션이 완료된 다음의 상태에서도 트랜잭션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야한다.
- 고립성 : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
- 지속성 : 트랜잭션이 정상적으로 종료된 다음에도 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.

---
### ⭐️ 참조자료 (감사합니다:)) ⭐️ <br>
[한재엽님의 깃허브 저장소](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database) <br> 
[백인감자님의 B+, B- 트리](https://potatoggg.tistory.com/174) <br>
[데이터베이스 정규화 1NF, 2NF, 3NF, BCNF](https://3months.tistory.com/193) <br> 
