# 완전탐색 패러다임

컴퓨터의 빠른 계산 능력을 이용해 가능한 경우의 수를 일일이 나열하면서 답을 찾는 방법을 말한다.  

## 재귀호출

자신이 수행할 작업을 유사한 형태의 여러 조각으로 쪼갠 뒤 그 중 하나의 조각을 수행하고 나머지 조각은 자기 자신을 호출해 실행하는 함수를 가리킨다.

> 기저 사례 (base case)  
> 쪼개지지 않는 가장 작은 작업을 가리킨다.  
> 모든 재귀 함수는 '더 이상 작업이 쪼개지지 않는' 최소한의 작업에 도달했을 때 답을 곧장 반환하는 조건문을 포함해야 한다.  

### Recursive Sum 함수 (재귀호출 기본)

```go
func recursiveSum(int n) int {
    if n == 1 {
        return n
    }
    return n + recursiveSum(n-1)
}
```

### 중첩 반복문 대체 함수

- 문제
  - 0번부터 차례대로 번호 매겨진 n개의 원소 중 네 개를 고르는 모든 경우를 출력

```go
import (
    "container/list"
    "fmt"
)

func pick(n int, picked *list.List, r int) {
    if r == 0 {
        // todo picked 리스트 출력
        ... 출력문 생략 ...
    }
    smallest := picked.Len()
    if smallest != 0 {
        smallest = picked.Back().Value.(int) + 1
    }
    for i := smallest; i < n; i++ {
        picked.PushBack(i)
        pick(n, picked, r-1)
        picked.Remove(picked.Back())
    }
}
```

> [풀이]  
> 빈 picked 리스트 struct에 n개의 원소들을 앞에서부터 순차적으로 넣는다.  
> r(고를 원소 수)가 모두 채워지면 현재 채워진 picked 리스트 값을 출력한다.  

### 문제: 소풍

> [22/02/02]  
> 소요시간: 약 5시간 + a  
> 이 문제가 난이도 '하'라는게 처참했지만 포기하지 않고 문제를 풀어냈다는 것이 엄청난 성과라고 생각한다.  
> 처음에 재귀 호출 방식으로 문제를 풀어내려고 했을 때, 문제도 나름 이해하는데 난이도가 있었고 재귀 호출의 패러다임이 낯설어서 상당히 시간 소요가 컸고 진전이 없었다.  
> 그래서 재귀 호출 방식 문제풀이는 뒤로 미루고 무식하게 코드를 작성하면서 문제를 이해했고 작성한 코드 베이스로 재귀 호출이 필요한 부분을 뽑아낼 수 있었다.

- 문제
  - 학생들을 두 명씩 짝을 지어 행동하게 하려고 한다.
  - 짝은 서로 친구 사이인 학생들끼리 맺어주려고 한다.
  - 각 학생들의 쌍에 대해 이들이 서로 친구인지 여부가 주어질 때, 학생들을 짝 지을 수 있는 방법의 수를 계산하는 프로그램을 작성하라.
  - 짝이 되는 학생들이 일부만 다르더라도 다른 방법이 된다.
    - 예) [태연, 제시카][써니, 티파니][효연, 유리]
    - 예) [태연, 제시카][써니, 유리][티파니, 효연]
- 입력
  - 테스트 케이스 수 : C
  - 학생의 수 : n (2 <= n <= 10)
  - 친구 쌍의 수 : m (0 <= m <= n(n-1)/2)
  - 서로 친구인 두 학생의 번호 나열 : l
- 출력
  - 모든 학생을 친구끼리만 짝지어줄 수 있는 방법의 수를 출력한다.

```console
<예제 입력>
3
2 1
0 1
4 6
0 1 1 2 2 3 3 0 0 2 1 3
6 10
0 1 0 2 1 2 1 3 1 4 2 3 2 4 3 4 3 5 4 5
<예제 출력>
1
3
4
```

```go
var line []string
var l3 = [][]string {
    {"n", "0", "1"},
	{"n", "0", "2"},
	{"n", "1", "2"},
	{"n", "1", "3"},
	{"n", "1", "4"},
	{"n", "2", "3"},
	{"n", "2", "4"},
	{"n", "3", "4"},
	{"n", "3", "5"},
	{"n", "4", "5"},
}
// 22/02/02
func Solution() int32 {
    strIdx := -1
    // 마킹 위치 확인
    for i := 0; i < len(l3); i++ {  
        if l3[i][0] == "n" {
            strIdx = i
            break
        }
    }
    // 모든 학생이 짝지어진 경우
    if len(line) == len(l3) {
        return 1
    }
    // 끝까지 마킹한 경우
    if strIdx == -1 {
        return 0
    }
    var cnt int32 = 0
    for j := strIdx; j < len(l3); j++ {
        contain := false
        // 현재 마킹된 학생 정보가 이미 라인(결과)에 포함되어 있는지 확인
        for k := 0; k < len(line); k++ {
            if l3[j][1] == line[k] || l3[j][2] == line[k] {
                contain = true
            }
        }
        if !contain {
            line = append(line, l3[j][1], l3[j][2])
            l3[j][0] = "y"
            cnt += Solution()
            // 다음 마킹으로 가기 전 라인(결과) 셋 정리
            l3 = l3[:len(l3)-2]
        } else {
            l3[j][0] = "y"
        }
        // 다음 마킹 가기 전 마킹 정리
        for n := j + 1; n < len(l3); n++ {
            l3[n][0] = "n"
        }
    }
    return cnt
}
```

