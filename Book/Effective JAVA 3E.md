# Effective JAVA 3/E

## 객체 생성과 파괴

> [22/02/09]  
>
> - 회사에서 엔터티 객체와 Http DTO 객체 리팩토링을 진행하면서 객체의 '캡슐화', 'API 디자인'을 고민 함.
> - 엔터티 객체의 경우 불필요한 Setter 메서드를 제거하며 되도록 필수 데이터는 생성자를 통해 초기화 하도록 하고 싶음.
> - Http DTO 객체의 경우 Setter 메서드는 지원하지 않으며 생성자를 통해 DTO 객체 필드 데이터 초기화를 깔끔하게 하고 싶음.
> - 엔터티 객체와 Http DTO 객체의 역할을 코드 상으로 완전히 분리시켜 다른 사람이 코드를 처음 접해도 단번에 이해할 수 있는 구조로 개선하고 싶음.

### 01: 생성자 대신 정적 팩터리 메서드를 고려하라

> [22/02/09] 이 부분은 Http DTO 객체에 적용 함. (예시> DTO.newInstance(엔터티객체))

인스턴스를 얻는 전통적인 수단

- public 생성자

다른 수단

- 정적 팩터리 메서드(static factory method)

```java
// 예시
public static Boolean valueOf(boolean b) {
  return b ? Boolean.TRUE : Boolean.FALSE;
}
```

장점

1. 이름을 가질 수 있다.
2. 인스턴스를 재활용할 수 있다.
3. [유연성] 반환(return) 타입의 하위 타입 객체를 반환할 수 있다.

단점

1. public, protected 생성자를 요구하는 상속에서는 제한적이다.
2. 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.

자주 사용하는 메서드 명

1. `from`: 하나의 매개변수를 받아 해당 타입의 인스턴스를 반환
2. `of`: 여러 개의 매개변수를 받아 적합한 타입의 인스턴스를 반환
3. `valueOf`: from과 of의 더 자세한 버전
4. `instance`, `getInstance`: (매개변수를 받는다면) 명시한 인스턴스를 반환하지만, 같은 인스턴스임은 보장하지 않는다.
5. `create`, `newInstance`: 매번 새로운 인스턴스를 생성하여 반환
6. `getType`, `newType`: Type은 반환할 객체의 타입(예 > getFireStore)으로 치환, 해당 타입을 반환
7. `type`: getType과 newType의 간결한 버전

### 02: 생성자에 매개변수가 많다면 빌더를 고려하라

> [22/02/09] 이 부분은 엔터티 객체에 적용 함.  
> 필수 데이터는 빌더 생성자로 반드시 입력받도록 하고 나머지 선택 데이터는 chainning setter로 적용  
> 빌더 To 엔터티 객체에 해당하는 build() 메서드에서는 필요한 위치에 Default 값을 세팅

빌더 도입이 필요한 상황

- 점층적 생성자 패턴(telescoping constructor pattern)
  - 필요한 매개 변수 조건에 따라 생성자를 늘려가는 방식
  - 매개변수가 많아지는 경우 클라이언트 코드를 작성하거나 읽기 어렵다.
- 자바빈즈 패턴(JavaBeans pattern)
  - 매개변수가 없는 생성자를 만들고 세터(setter) 메서드를 호출해 매개변수 값을 설정하는 방식
  - 매개변수가 많으면 많을수록 세터 메서드 호출이 많아진다.
    - `Builder 패턴도 같은 조건이면 동일한 상황이니 비슷하다고 생각한다. (22/02/09)`
  - 생성한 객체가 매개변수가 모두 초기화된 완전한 상태라고 보장하기 어렵다.
    - 일관성(consistency)가 무너진 상태
  - 클래스를 불변(private) 상태로 만들 수 없다.

빌더 패턴

1. 필수 매개변수만으로 생성자를 호출해 빌더 객체를 얻는다.
2. 빌더 객체가 제공하는 세터 메서드로 선택 매개변수를 설정한다.
3. 매개변수가 없는 build 메서드를 호출해 완전한 객체를 얻는다.

장점

1. 코드를 읽고 쓰기 쉽다.
2. 불변식 검사를 통해 일관성을 보장할 수 있다.
3. 계층적으로 설계된 클래스와 함께 쓰기 좋다.

## 열거 타입과 애너테이션

> [22/03/22]  
>  
> 도메인 객체를 생성하면서 적은 데이터도 열거 타입으로 생성하는 게 맞는지 의심되어 이 부분을 찾아보게 되었음.

### 34: int 상수 대신 열거 타입을 사용하라

정수 열거 패턴(int enum pattern) 단점

- 별도 이름공간(namespace)을 자바에서 지원하지 않기 때문에 접두어로 이름 사용
- 타입 안전을 보장할 방법이 없음
- 가독성이 좋지 않음

열거 타입(enum type) 특징

- 완전한 형태의 클래스
- 인스턴스를 직접 생성하거나 확장할 수 없음
- 인스턴스가 딱 하나만 존재
- 열거 타입에 메서드나 필드를 추가할 수 있다.

## 예외

> [22/01/25]  
>
> - 회사에서 개발한 RestController에 try-catch문 Exception 처리 코드가 너무 많아 찾아보게 되었음.
> - 위와 같은 현상은 API를 호출하는 클라이언트에게 상세한 에러 메세지를 전달하고자는 목적으로 인해 발생.
> - 제일 큰 현 불만은 catch에서 핸들링해야하는 Exception이 많아 라인 수가 길어 줄이고 싶음.
> - 추가로 개선하고 싶은 점은 되도록 커스텀 예외는 피하면서 적절하게 표준 예외를 사용하여 깔끔하게 사용하고 싶음.

### 71: 필요 없는 검사 예외 사용은 피하라  

`검사예외: Checked Exception`  

- 불편한 점
  - Checked Exception을 던지는 API를 이용하는 클라이언트 쪽에서 `try - catch 구문`으로 예외를 잡는 코드를 작성하던가 더 바깥으로 던지는 처리를 꼬리표처럼 해야한다.  
  - JDK 8 이상부터는 스트림(Stream)에서 `Checked Exception`을 던지는 API를 호출할 수 없어서 제한적이다.

- 대체
  - (1) 결과를 담은 `Optional`을 사용하여 `Checked Exception` 코드를 제거한다.
    - 이 방법의 단점은 `예외 상황의 메세지를 담을 수 없다`는 점이다.
  - (2) `Checked 메서드` -> `UnChecked 메서드` + `상태 검사 메서드`로 쪼개기.

꼭 필요한 곳에서만 `Checked Exception`을 사용해야 한다.  
남용하면 사용하기 고통스러운 API가 된다.  

### 72: 표준 예외를 사용하라

- 표준 예외 사용 장점
  - 다른 프로그래머들도 익숙한 예외라 사용하기 쉬워진다.
    - `위는 책 내용 중 일부를 인용한건데 사용하기 쉽다는 구문은 이해하기 어렵다. 예외 상황과 표준 예외의 의미가 애매모호하다면 사용하기 어렵다는 생각이 든다. (22/01/25)`

- 단점
  - 직렬화할 수 있다. (🔴 직렬화 정리 필요)

### 73: 추상화 수준에 맞는 예외를 던지라

핵심

- 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔 던져야 한다.

저수준 예외가 디버깅에 도움이 되는 경우 **예외 연쇄(exception chaining)** 을 사용하는게 좋다.  

```java
try {
  ...Expression
} catch (LowerLevelException cause) {
  throw new HigherLevelException(cause);
}
```

근데 되도록 저수준에서 예외가 발생하도록 만들지 말고 최대한 상위 계층에서 핸들링한다. (미리 검사, 로깅 처리)

### 76: 가능한 한 실패 원자적으로 만들라

> 실패 원자적(Failure Atomic)  
> 호출된 메서드가 실패해도 해당 객체는 메서드 호출 전 상태를 유지하는 특성

- 실패 원자적으로 만드는 방법
  - (1) 메서드를 불변 객체(Immutable Object)로 설계한다.
    - final 키워드 방법
    - 방어적 복사(defensive-copy) 방법
  - (2) 잠재적 예외인 매개변수의 유효성 검사
    - 미리 잠재적 예외를 확인 후 로직 수행
  - (3) 실패 가능성 있는 코드가 상태 변경 코드보다 앞에 배치한다.
  - (4) 객체의 임시 복사본으로 작업 후 성공하면 성공본, 실패하면 원래 객체로 교체한다.
  - (5) 발생한 실패를 가로채는 복구 코드를 작성하고 이전 상태로 되돌림.
    - 주로 내구성(디스크 기반의)을 보장해야 하는 자료구조에 쓰임.