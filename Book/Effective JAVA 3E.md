# Effective JAVA 3/E

## 예외

> [22/01/25]  
> - 회사에서 개발한 RestController에 try-catch문 Exception 처리 코드가 너무 많아 찾아보게 되었음.
> - 위와 같은 현상은 API를 호출하는 클라이언트에게 상세한 에러 메세지를 전달하고자는 목적으로 인해 발생.
> - 제일 큰 현 불만은 catch에서 핸들링해야하는 Exception이 많아 라인 수가 길어 줄이고 싶음.
> - 추가로 개선하고 싶은 점은 되도록 커스텀 예외는 피하면서 적절하게 표준 예외를 사용하여 깔끔하게 사용하고 싶음.

### 71: 필요 없는 검사 예외 사용은 피하라  

`검사예외: Checked Exception`  

- 불편한 점
  - Checked Exception을 던지는 API를 이용하는 클라이언트 쪽에서 `try - catch 구문`으로 예외를 잡는 코드를 작성하던가 더 바깥으로 던지는 처리를 꼬리표처럼 해야한다.  
  - JDK 8 이상부터는 스트림(Stream)에서 `Checked Exception`을 던지는 API를 호출할 수 없어서 제한적이다.

- 대체
  - (1) 결과를 담은 `Optional`을 사용하여 `Checked Exception` 코드를 제거한다.
    - 이 방법의 단점은 `예외 상황의 메세지를 담을 수 없다`는 점이다.
  - (2) `Checked 메서드` -> `UnChecked 메서드` + `상태 검사 메서드`로 쪼개기.

꼭 필요한 곳에서만 `Checked Exception`을 사용해야 한다.  
남용하면 사용하기 고통스러운 API가 된다.  

### 72: 표준 예외를 사용하라

- 표준 예외 사용 장점
  - 다른 프로그래머들도 익숙한 예외라 사용하기 쉬워진다.
    - `위는 책 내용 중 일부를 인용한건데 사용하기 쉽다는 구문은 이해하기 어렵다. 예외 상황과 표준 예외의 의미가 애매모호하다면 사용하기 어렵다는 생각이 든다. (22/01/25)`

- 단점
  - 직렬화할 수 있다. (🔴 직렬화 정리 필요)

### 76: 가능한 한 실패 원자적으로 만들라

> 실패 원자적(Failure Atomic)  
> 호출된 메서드가 실패해도 해당 객체는 메서드 호출 전 상태를 유지하는 특성

- 실패 원자적으로 만드는 방법
  - (1) 메서드를 불변 객체(Immutable Object)로 설계한다.
    - final 키워드 방법
    - 방어적 복사(defensive-copy) 방법
  - (2) 잠재적 예외인 매개변수의 유효성 검사
    - 미리 잠재적 예외를 확인 후 로직 수행
  - (3) 실패 가능성 있는 코드가 상태 변경 코드보다 앞에 배치한다.
  - (4) 객체의 임시 복사본으로 작업 후 성공하면 성공본, 실패하면 원래 객체로 교체한다.
  - (5) 발생한 실패를 가로채는 복구 코드를 작성하고 이전 상태로 되돌림.
    - 주로 내구성(디스크 기반의)을 보장해야 하는 자료구조에 쓰임.